"Segment Tree": {
		"prefix": ["data_structure-segment_tree"],
		"body": [
			"#pragma region Segment Tree",
			"",
			"template <typename _Type>",
			"class segment_tree",
			"{",
			"\tusing _Function = function<_Type(_Type, _Type)>;",
			"",
			"public:",
			"\tint                   m_base_index;",
			"\tint                   m_size, m_height;",
			"\tvector<vector<_Type>> m_data;",
			"\t_Function             m_func;",
			"",
			"public:",
			"\ttemplate <typename _Iterator>",
			"\tsegment_tree(_Iterator _begin, _Iterator _end, const _Function& _func, const int& _base_index=0)",
			"\t\t: m_func(_func), m_base_index(_base_index)",
			"\t{",
			"\t\tm_size   = _end - _begin;",
			"\t\tm_height = m_size > 1 ? 33 - __builtin_clz(m_size - 1) : 1;",
			"",
			"\t\tm_data        = vector<vector<_Type>>(m_height);",
			"\t\tm_data.back() = vector<_Type>(_begin, _end);",
			"",
			"\t\tint mask = m_size;",
			"\t\tfor (int i = m_height - 2; i >= 0; i--)",
			"\t\t{",
			"\t\t\tm_data[i].resize((mask + 1) >> 1);",
			"\t\t\tfor (int j = (mask >> 1) - 1; j >= 0; j--)",
			"\t\t\t{",
			"\t\t\t\tm_data[i][j] = _func(",
			"\t\t\t\t\tm_data[i + 1][j << 1],",
			"\t\t\t\t\tm_data[i + 1][(j << 1) + 1]",
			"\t\t\t\t);",
			"\t\t\t}",
			"\t\t\tif (mask & 1)",
			"\t\t\t\tm_data[i].back() = m_data[i + 1].back();",
			"\t\t\t",
			"\t\t\t++mask >>= 1;",
			"\t\t}",
			"\t}",
			"",
			"\ttemplate <typename _Container>",
			"\tsegment_tree(const _Container& _container, const _Function& _func, const int& _base_index=0)",
			"\t\t: segment_tree(_container.begin(), _container.end(), _func, _base_index)",
			"\t{}",
			"",
			"\ttemplate <typename _Container, size_t _Size>",
			"\tsegment_tree(const _Container (&_container)[_Size], const _Function& _func, const int& _base_index=0)",
			"\t\t: segment_tree(_container, _container + _Size, _func, _base_index)",
			"\t{}",
			"\t",
			"\tconst _Type get(const int& _index) const",
			"\t{",
			"\t\treturn m_data[0][0];",
			"\t}",
			"",
			"\tconst _Type get(const int& _lindex, const int& _rindex) const",
			"\t{",
			"\t\tint l = _lindex - m_base_index;",
			"\t\tint r = _rindex - m_base_index;",
			"",
			"\t\tif (l == r)",
			"\t\t\treturn m_data.back()[l];",
			"",
			"\t\t_Type left  = m_data.back()[l];",
			"\t\t_Type right = m_data.back()[r];",
			"\t\tfor (int h = m_height - 1; (l >> 1) < (r >> 1); l >>= 1, r >>= 1, h--)",
			"\t\t{",
			"\t\t\tif (!(l & 1))",
			"\t\t\t\tleft = m_func(left, m_data[h][l + 1]);",
			"\t\t\tif (r & 1)",
			"\t\t\t\tright = m_func(m_data[h][r - 1], right);",
			"\t\t}",
			"\t\treturn m_func(left, right);",
			"\t}",
			"",
			"",
			"\tvoid update(const int &_index, const _Type& _new_value)",
			"\t{",
			"\t\tint m = _index - m_base_index;",
			" ",
			"\t\t_Type value = _new_value;",
			"\t\tm_data.back()[m] = value;",
			"\t\tfor (int h = m_height - 1, mask = m_size; h > 0; h--, m >>= 1)",
			"\t\t{",
			"\t\t\tif (!(m & 1)) {",
			"\t\t\t\tm_data[h - 1][m >> 1] = m < m_data[h].size() - 1 ? m_func(value, m_data[h][m + 1]) : value;",
			"\t\t\t\tvalue = m_data[h - 1][m >> 1];",
			"\t\t\t}",
			"\t\t\telse",
			"\t\t\t{",
			"\t\t\t\tm_data[h - 1][m >> 1] = m_func(m_data[h][m - 1], value);",
			"\t\t\t\tvalue = m_data[h - 1][m >> 1];",
			"\t\t\t}",
			"\t\t}",
			"\t}",
			"",
			"",
			"\tconst inline size_t size() const",
			"\t\t{ return m_size; }",
			"\t",
			"\tconst inline size_t height() const",
			"\t\t{ return m_height; }",
			"",
			"\tconst inline auto begin() const",
			"\t\t{ return m_data.begin(); }",
			"",
			"\tconst inline auto end() const",
			"\t\t{ return m_data.end(); }",
			"",
			"\tconst inline auto rbegin() const",
			"\t\t{ return m_data.rbegin(); }",
			"",
			"\tconst inline auto rend() const",
			"\t\t{ return m_data.rend(); }",
			"",
			"",
			"\tconst auto operator[] (const int &_index) const",
			"\t\t{ return m_data.back()[_index - m_base_index]; }",
			"",
			"\toperator vector<vector<_Type>>() const",
			"\t\t{ return m_data; }",
			"",
			"",
			"\tfriend ostream& operator<<(ostream& _os, const segment_tree<_Type>& _segment_tree)",
			"\t\t{ return _os << static_cast<vector<vector<_Type>>>(_segment_tree); }",
			"};",
			"",
			"#pragma endregion"
		]
	},
